<!DOCTYPE html>
<html lang="zh" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charSet="utf-8"/>
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"/>
    <title>Funds</title>
    <link href="/css/bootstrap.min.css" rel="stylesheet">
</head>
<body class="py-5">
<div class="d-flex justify-content-center">
    <div class="col-sm-8 col-md-10 col-lg-9 align-self-center">
        <div class="col">
            <div class="card">
                <div class="card-header with-border d-flex justify-content-center">
                    <h3 id="score">Scores:</h3>
                </div>
                <div class="card-body d-flex justify-content-center">
                    <canvas id="tetris"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>
</body>
<script type="module">
    import GUI from "./js/lil-gui.esm.js";
    import {PIECES} from "./js/piece.js";
    import {createHDCanvas} from "./js/createHDCanvas.js";
    import {drawSquare} from "./js/drawSquare.js";
    import {createBoard} from "./js/board.js";
    import {keyControl} from "./js/keyControl.js";

    const cvs = document.getElementById("tetris");
    const ctx = cvs.getContext("2d");
    createHDCanvas(cvs, ctx)
    const scoreElement = document.getElementById("score");

    const SQUARE_SIZE = 25;
    const ROW = 20;
    const COL = 10;
    const VACANT = "white"
    let score = 0;
    // 存储每个board的颜色
    let board = createBoard(ROW, COL, VACANT);

    function drawBoard() {
        for (let r = 0; r < ROW; r++) {
            for (let c = 0; c < COL; c++) {
                // 之所以用board[r][c]的颜色是因为board存了lock之后的颜色，即已经落下去的方块的颜色
                drawSquare(ctx, c, r, board[r][c], SQUARE_SIZE)
            }
        }
    }


    class Piece {
        constructor(tetromino, color) {
            // 形状
            this.tetromino = tetromino
            // 颜色
            this.color = color
            this.tetrominoN = 0; // we start from the first pattern
            // 当前形状
            this.activeTetromino = this.tetromino[this.tetrominoN];
            // 从第几行/第几列开始绘制
            this.x = 3;
            this.y = -1;
        }

        fill(color) {
            for (let row = 0; row < this.activeTetromino.length; row++) {
                for (let column = 0; column < this.activeTetromino.length; column++) {
                    // 如果[r][c]是1，则表示在rc位置绘制，这里1实际上是表示占位；如果是0，就跳过该位置
                    // 如果不判断，会绘制r*c个square
                    this.activeTetromino[row][column] ? drawSquare(ctx, this.x + column, this.y + row, color, SQUARE_SIZE) : null;
                }
            }
        }

        draw() {
            this.fill(this.color)
        }

        unDraw() {
            this.fill(VACANT)
        }

        moveDown() {
            if (!this.collision(0, 1, this.activeTetromino)) {
                this.unDraw();
                this.y++;
                this.draw();
            } else {
                this.lock()
                p = randomPiece();
            }
        }

        moveRight() {
            if (!this.collision(1, 0, this.activeTetromino)) {
                this.unDraw();
                this.x++;
                this.draw();
            }
        }

        moveLeft() {
            if (!this.collision(-1, 0, this.activeTetromino)) {
                this.unDraw();
                this.x--;
                this.draw();
            }
        }

        rotate() {
            let nextPattern = this.tetromino[(this.tetrominoN + 1) % this.tetromino.length];
            let kick = 0;

            if (this.collision(0, 0, nextPattern)) {
                if (this.x > COL / 2) {
                    // it's the right wall
                    kick = -1; // we need to move the piece to the left
                } else {
                    // it's the left wall
                    kick = 1; // we need to move the piece to the right
                }
            }

            if (!this.collision(kick, 0, nextPattern)) {
                this.unDraw();
                this.x += kick;
                this.tetrominoN = (this.tetrominoN + 1) % this.tetromino.length; // (0+1)%4 => 1
                this.activeTetromino = this.tetromino[this.tetrominoN];
                this.draw();
            }
        }

        collision(x, y, piece) {
            for (let r = 0; r < piece.length; r++) {
                for (let c = 0; c < piece.length; c++) {
                    // if the square is empty, we skip it
                    if (!piece[r][c]) {
                        continue;
                    }
                    // coordinates of the piece after movement
                    let newX = this.x + c + x;
                    let newY = this.y + r + y;

                    // conditions
                    if (newX < 0 || newX >= COL || newY >= ROW) {
                        // console.log(newX, newY)
                        return true;
                    }
                    // skip newY < 0; board[-1] will crush our game
                    if (newY < 0) {
                        continue;
                    }

                    // check if there is a locked piece already in place
                    if (board[newY][newX] !== VACANT) {
                        return true;
                    }
                }
            }
            return false;
        }

        lock() {
            for (let r = 0; r < this.activeTetromino.length; r++) {
                for (let c = 0; c < this.activeTetromino.length; c++) {
                    // we skip the vacant squares
                    if (!this.activeTetromino[r][c]) {
                        continue;
                    }
                    // pieces to lock on top = game over
                    if (this.y + r < 0) {
                        alert("Game Over");
                        // stop request animation frame
                        gameOver = true;
                        break;
                    }
                    // we lock the piece
                    board[this.y + r][this.x + c] = this.color;
                }
            }
            // remove full rows
            for (let r = 0; r < ROW; r++) {
                let isRowFull = true;
                for (let c = 0; c < COL; c++) {
                    isRowFull = isRowFull && (board[r][c] !== VACANT);
                }
                if (isRowFull) {
                    // if the row is full
                    // we move down all the rows above it
                    for (let y = r; y > 1; y--) {
                        for (let c = 0; c < COL; c++) {
                            board[y][c] = board[y - 1][c];
                        }
                    }
                    // the top row board[0][.] has no row above it
                    for (let c = 0; c < COL; c++) {
                        board[0][c] = VACANT;
                    }
                    // increment the score
                    score += 10;
                }
            }
            // update the board
            drawBoard();

            // update the score
            scoreElement.innerHTML = `Scores:${score}`;
        }
    }

    function randomPiece() {
        let r = Math.floor(Math.random() * PIECES.length) // 0 -> 6
        return new Piece(PIECES[r][0], PIECES[r][1]);
    }

    let p = randomPiece();
    document.addEventListener("keydown", function (event) {
        keyControl(event, p)
    });

    let dropStart = Date.now();
    let gameOver = false;
    let gui_controls;

    function addControl() {
        let gui = new GUI();
        document.body.appendChild(gui.domElement);
        gui_controls = {
            downSpeed: 0.1
        };

        gui.add(gui_controls, 'downSpeed', 0, 10);
    }

    function init() {
        let now = Date.now();
        let delta = now - dropStart;
        if (delta > 1000 / gui_controls.downSpeed) {
            p.moveDown();
            dropStart = Date.now();
        }
        if (!gameOver) {
            requestAnimationFrame(init);
        }
    }
    drawBoard();
    addControl();
    init();
</script>
</html>